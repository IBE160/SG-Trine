# ibe160 - Scale Adaptive Architecture

## 1. Project Context Understanding

I'm reviewing your project documentation for ibe160 - Prioritize.
I see 4 epics with 18 total stories, alongside a detailed UX specification.

**Key aspects I notice:**
-   **Core Functionality:** A comprehensive to-do list, with robust backend storage.
-   **AI Integration:** Central to intelligent task categorization, priority suggestions, and future productivity enhancements leveraging Gemini 2.5 Pro.
-   **ADHD-Centric Design:** Focused on a hyper-minimalist UI, intuitive guidance, and features specifically designed to reduce overwhelm and enhance focus.
-   **Technology Stack:** Next.js frontend, FastAPI backend, Supabase for database, authentication, and real-time updates, deployed via Vercel.
-   **Non-Functional Requirements:** High performance, strong security, inherent scalability, and adherence to WCAG AA accessibility standards.
-   **UX Principles:** Emphasizes calm, control, and a novel "Plan My Day" workflow.

This understanding will help me guide you through the architectural decisions needed to ensure AI agents implement this consistently.

## 2. Starter Template Decision

You have approved the use of a Next.js/FastAPI boilerplate. A typical setup involves initializing Next.js and FastAPI projects separately and configuring them to work together.

Here are the recommended initialization steps to create your project's foundation:

```bash
# 1. Create Next.js Frontend
npx create-next-app@latest nextjs-frontend --typescript --eslint --app --src-dir --import-alias "@/*"

# 2. Create FastAPI Backend
# In the project root, at the same level as the 'nextjs-frontend' directory
mkdir api
cd api
python -m venv venv
# Activate virtual environment (e.g., source venv/bin/activate or .\venv\Scripts\Activate.ps1)
pip install fastapi uvicorn[standard] supabase-py pydantic-settings
# Create main.py inside 'api' directory
cd ..
```

**Note for First Implementation Story:**
The very first implementation story should involve executing these commands, setting up the monorepo structure, and deploying a minimal 'Hello World' to verify the end-to-end connection between the Next.js frontend and the FastAPI backend deployed as a serverless function on Vercel.

## 3. Decision Summary

The following sections document the architectural decisions made for the `ibe160 - Prioritize` application.

### 3.1. Critical Architectural Decisions

*   **Database Schema:** A simple, relational schema in Supabase (PostgreSQL) with tables for `users`, `tasks`, `labels`, and `task_labels`.
*   **Supabase Integration:** The frontend uses `@supabase/supabase-js` for auth and real-time subscriptions. The backend uses `supabase-py` for data access, enforcing Row Level Security.
*   **AI Integration:** The FastAPI backend will exclusively handle calls to the Gemini 2.5 Pro API, managing prompts and implementing robust error handling and fallbacks.
*   **API Design:** A versioned RESTful API (`/api/v1`) built with FastAPI, using Pydantic for strict data validation.
*   **Frontend/Backend Communication:** The Next.js frontend communicates with the FastAPI backend via a type-safe API client, sending Supabase JWTs for authentication.
*   **Deployment:** The project is deployed as a monorepo on Vercel, with the FastAPI backend placed in the `api/` directory to be deployed as serverless functions.

### 3.2. Important Architectural Decisions

*   **Authentication Flow:** Secure JWT-based authentication flow managed by Supabase, with backend validation.
*   **File Storage:** Signed URLs will be generated by the backend for direct-to-storage uploads from the frontend to Supabase Storage, secured by RLS policies.
*   **Search:** Initial search functionality will be implemented using PostgreSQL's built-in Full-Text Search (FTS).
*   **Caching:** A simple in-memory cache (`fastapi-cache2`) will be used in the backend for non-user-specific data.
*   **Configuration:** Secrets and configuration will be managed via environment variables (`.env.local` for development, Vercel project settings for production).

### 3.3. Future-Facing Decisions (Post-MVP)

*   **Email:** `Resend` is the recommended service for future transactional email needs.
*   **Background Jobs:** `Inngest` is recommended for its serverless-friendly architecture for future background task processing.
*   **Vector Search:** `pgvector` is the chosen extension for PostgreSQL to enable future semantic search capabilities.

## 4. Cross-Cutting Concerns

*   **Error Handling:**
    *   **Frontend:** React Error Boundaries for rendering errors and a global handler for unexpected exceptions, with user-facing errors displayed via toast notifications.
    *   **Backend:** A global exception handler middleware in FastAPI to catch all errors and return standardized JSON error responses.
*   **Logging:**
    *   **Frontend:** Standard `console.log` in development; a remote logging service (e.g., Sentry, Logtail) for production.
    *   **Backend:** Structured JSON logging using Python's built-in `logging` module.
*   **Date/Time Handling:** `UTC` will be used for all backend and database operations. The frontend is responsible for converting to the user's local timezone for display.
*   **API Response Format:** Successful responses return data directly. Error responses return a JSON object: `{"detail": "Error message"}`.
*   **Testing Strategy:**
    *   **Frontend:** `Jest` and `React Testing Library` for unit/integration tests; `Playwright` for E2E tests.
    *   **Backend:** `pytest` for unit and integration tests.

## 5. Project Structure

The project will be organized as a monorepo. The Vercel deployment strategy requires the FastAPI application to be inside the Next.js project root, conventionally in an `api/` directory.

```
/
├── .gitignore
├── nextjs-frontend/
│   ├── src/
│   │   ├── app/                # Next.js App Router (pages and layouts)
│   │   ├── components/         # Shared React components (UI, forms, etc.)
│   │   ├── lib/                # Library code (API client, utils)
│   │   ├── styles/             # Global styles
│   │   └── ...
│   ├── public/                 # Static assets (images, fonts)
│   ├── .env.local              # Frontend environment variables
│   ├── next.config.js
│   ├── package.json
│   └── ...
├── api/
│   ├── .venv/                  # Python virtual environment
│   ├── app/                    # Main application folder for FastAPI
│   │   ├── __init__.py
│   │   ├── main.py             # FastAPI app instance and middleware
│   │   ├── core/               # Configuration, settings
│   │   ├── db/                 # Database session management
│   │   ├── models/             # Pydantic models
│   │   ├── services/           # Business logic
│   │   └── api/                # API routers and endpoints
│   ├── tests/                  # Backend tests
│   ├── .env.local              # Backend environment variables
│   └── requirements.txt        # Python dependencies
└── README.md
```

## 6. Epic to Architecture Mapping

*   **Epic 1 (Foundation & Core Task Management):** Supported by the core `Next.js`/`FastAPI` structure, `Supabase` integration for data persistence (schema in 4.1), and `Vercel` deployment strategy.
*   **Epic 2 (AI-Powered Task Intelligence):** Supported by the `AI Integration Strategy` (4.3), which defines how the `FastAPI` backend communicates with Gemini. The `labels` table in the database schema supports this epic.
*   **Epic 3 (Advanced Task Management & User Experience):** Supported by the `Styling Foundation` (Tailwind/shadcn), `Real-time` integration with Supabase, and the `Search Functionality` decision (5.3).
*   **Epic 4 (AI-Enhanced Productivity Tools - Post-MVP):** Supported by the `Background Task Processing` (6.2) and `Advanced AI Features (Vector Database)` (6.3) decisions, providing a clear path for future implementation.

## 7. Novel Architectural Patterns

### Pattern: "Plan My Day" AI Workflow

This pattern is a defining feature of the application, transforming a user's unstructured input into an actionable plan.

*   **Purpose:** To reduce user cognitive load and decision paralysis by automatically breaking down, prioritizing, and organizing a list of tasks.
*   **Components:**
    *   **Frontend:** A simple UI for task "brain-dumping".
    *   **FastAPI Backend:** An endpoint (e.g., `/api/v1/plan-my-day`) that orchestrates the workflow.
    *   **Gemini 2.5 Pro API:** Used for task analysis, sub-task generation, and prioritization.
    *   **Supabase DB:** To persist the resulting structured tasks.
*   **Data Flow:**
    1.  User submits a list of unstructured tasks (e.g., "laundry, finish report, doctor's appointment 10am") to the frontend.
    2.  Frontend sends this list to the `/api/v1/plan-my-day` endpoint on the backend.
    3.  The backend constructs a detailed prompt for the Gemini API, asking it to break down tasks, estimate time, assign priorities, and identify deadlines.
    4.  The backend receives the structured data from Gemini.
    5.  The backend validates and saves the structured tasks and sub-tasks to the Supabase database.
    6.  The frontend receives confirmation and updates the UI to show the new, organized plan, often in a "Focused Task View" showing only the first task.
*   **Implementation Guide:** The core logic resides in the backend. It must be robust against variations in user input and potential API failures from the AI service. A well-engineered prompt is critical to the success of this pattern.

## 8. Implementation Patterns (Consistency Rules)

To ensure all developers and AI agents write consistent and predictable code, the following conventions MUST be followed.

*   **API Naming:**
    *   **Endpoints:** `kebab-case`, plural nouns (e.g., `/api/v1/to-do-tasks`).
    *   **JSON Properties:** `snake_case` (e.g., `{"task_id": 123}`).
*   **Component Naming (React):**
    *   **Files:** `PascalCase` (e.g., `TaskCard.tsx`).
    *   **Components:** `PascalCase` (e.g., `<TaskCard />`).
*   **Variable Naming:**
    *   **TypeScript/JS:** `camelCase`.
    *   **Python:** `snake_case`.
*   **File Structure:**
    *   **Frontend:** Components will be organized by feature in the `src/components` directory (e.g., `src/components/tasks/TaskCard.tsx`).
    *   **Backend:** Logic will be separated into `services`, `models`, and `api` directories.
*   **State Management (Frontend):**
    *   Local component state will be managed by `useState`.
    *   Global state (e.g., user session, shared data) will be managed by `Zustand`.
*   **Styling:**
    *   All styling will be done using `Tailwind CSS` utility classes. Custom CSS will be avoided unless absolutely necessary. `shadcn/ui` components will be the default.

---

## 9. Validation Summary

This document has been validated against the project's architectural checklist.

*   **Architecture Completeness:** Complete
*   **Version Specificity:** Some Missing. Specific versions of npm packages and Python libraries should be verified and pinned before starting implementation.
*   **Pattern Clarity:** Clear
*   **AI Agent Readiness:** Ready

### Recommended Actions Before Implementation

1.  **Verify Technology Versions:** Before running `npm`/`pip` install, verify the latest stable versions of all major libraries (Next.js, React, FastAPI, Pydantic, Supabase libraries) and pin them in `package.json` and `requirements.txt`.

---

This document provides a comprehensive architectural foundation for the `ibe160 - Prioritize` project, ensuring all current requirements are met and providing a clear path for future growth.