<story-context id="{bmad_folder}/bmm/workflows/4-implementation/story-context/template" v="1.0">
  <metadata>
    <epicId>2</epicId>
    <storyId>1</storyId>
    <title>AI-Generated Smart Labels</title>
    <status>drafted</status>
    <generatedAt>fredag 12. desember 2025</generatedAt>
    <generator>BMAD Story Context Workflow</generator>
    <sourceStoryPath>docs/sprint-artifacts/2-1-ai-generated-smart-labels.md</sourceStoryPath>
  </metadata>

  <story>
    <asA>a user</asA>
    <iWant>the system to automatically generate smart labels for my tasks</iWant>
    <soThat>I can quickly categorize and understand my tasks at a glance</soThat>
    <tasks>
- [ ] **Task 1: Implement Backend AI Integration (AC 1.1, 1.2, 1.3)**
  - [ ] Create a new FastAPI endpoint or a background task service for handling AI processing.
  - [ ] This service will take a task's title and description as input.
  - [ ] It will construct a structured prompt for the Gemini API, asking for relevant labels.
  - [ ] The call to the Gemini API MUST be made from the backend to protect the API key.
  - [ ] Implement robust error handling: If the API call fails, the task is still created without labels, and the error is logged.

- [ ] **Task 2: Update Database Schema and Logic (AC 1.2)**
  - [ ] Create a `labels` table for unique label names.
  - [ ] Create a `task_labels` join table to create a many-to-many relationship between tasks and labels.
  - [ ] After the Gemini API returns labels, the backend will parse the response and populate these tables accordingly.

- [ ] **Task 3: Implement Frontend Display (AC 1.4)**
  - [ ] Enhance the `TaskList` and `TaskListItem` components to display labels associated with a task.
  - [ ] Display the labels as distinct visual elements (e.g., tags or badges).
  - [ ] The UI should gracefully handle tasks that do not have any labels.
    </tasks>
  </story>

  <acceptanceCriteria>
1.  **AI Label Generation:**
    1.1. When a task is created or edited, the backend asynchronously calls the Gemini API with a structured prompt for label generation.
    1.2. On a successful API response, the backend populates the `labels` and `task_labels` tables in the database.
    1.3. If the AI call fails, the task is still created successfully without any labels, and the error is logged.
2.  **UI Display:**
    2.1. When a task with labels is displayed in the frontend, the labels are shown as distinct visual elements (e.g., tags or badges).
  </acceptanceCriteria>

  <artifacts>
    <docs>
      <doc>
        <path>docs/architecture-2025-11-28.md</path>
        <title>ibe160 - Scale Adaptive Architecture</title>
        <section>4.3. AI Integration Strategy</section>
        <snippet>Specifies that all AI (Gemini) calls must be made from the secure backend to protect API keys.</snippet>
      </doc>
      <doc>
        <path>docs/architecture-2025-11-28.md</path>
        <title>ibe160 - Scale Adaptive Architecture</title>
        <section>4.1. Database Schema</section>
        <snippet>Defines the many-to-many relationship for tasks and labels using `tasks`, `labels`, and `task_labels` tables.</snippet>
      </doc>
    </docs>
    <code>
      <file>
        <path>api/app/services/ai_service.py</path>
        <description>New service module in the backend to handle all interactions with the Gemini API.</description>
      </file>
       <file>
        <path>api/app/main.py</path>
        <description>The task creation/update endpoints will trigger the AI service asynchronously.</description>
      </file>
      <file>
        <path>nextjs-frontend/src/components/task-list-item.tsx</path>
        <description>Component to be updated to display the label badges.</description>
      </file>
    </code>
  </artifacts>

  <constraints>
- The AI API key must never be exposed to the frontend.
- Failure in the AI label generation process must not block the core task creation/update functionality.
</constraints>
  <interfaces>
    <api type="Internal">
        <description>The backend will make an API call to the Google Gemini API.</description>
    </api>
  </interfaces>
  <tests>
    <ideas>
    - Unit test the AI service to ensure it constructs the correct prompt for the Gemini API.
    - Mock the Gemini API response to test the backend logic for populating the database tables.
    - Test the error handling path where the Gemini API call fails.
    - Component test the `TaskListItem` to verify it correctly displays labels or an empty state.
  </ideas>
  </tests>
</story-context>